#!/bin/sh
# shellcheck shell=sh

set -u

# Map GPT PARTLABEL to slot for udev IMPORT.
# This script is boot critical and must be compatible with minimal shell
# environments such as klibc, and be as POSIX compliant as possible.

err() {
   msg="ERROR: $*"
   if [ -w /dev/kmsg ]; then
      echo "$msg" > /dev/kmsg 2>/dev/null || :
   fi
   echo "$msg" >&2
}

die() { err "$@"; exit 1; }

prefix=disk/by-slot
udev_fmt=0

ID_PART_ENTRY_NAME=${ID_PART_ENTRY_NAME-}
DEVNAME=${DEVNAME-}
DM_NAME=${DM_NAME-}


while getopts "d:l:m:u" opt; do
   case $opt in
      d) DEVNAME="$OPTARG";;
      l) ID_PART_ENTRY_NAME="$OPTARG";;
      m) DM_NAME="$OPTARG";;
      u) udev_fmt=1;;
      *) ;;
   esac
done

[ -n "$DEVNAME" ] || die "missing dev"
[ -n "$ID_PART_ENTRY_NAME" ] || die "missing label"


read_dt_u32() {
   # shellcheck disable=SC2046
   # shellcheck disable=SC2312
   set -- $(od -An -tu1 -N4 "$1" 2>/dev/null)
   [ $# -eq 4 ] || return 1
   echo $(( $1*16777216 + $2*65536 + $3*256 + $4 ))
}


# Determine boot device to infer active slot suffix
BOOT_MODE=$(read_dt_u32 /proc/device-tree/chosen/bootloader/boot-mode) || die "no boot-mode"
BOOT_PARTN=$(read_dt_u32 /proc/device-tree/chosen/bootloader/partition) || die "no boot-part"
case $BOOT_MODE in
   1) BOOT_DEV=mmcblk0;;
   6) BOOT_DEV=nvme0n1;;
   *) die "unsupported bootmode $BOOT_MODE";;
esac

BOOT_BLKDEV="/dev/${BOOT_DEV}p${BOOT_PARTN}"
test -b "$BOOT_BLKDEV" || die "Invalid boot blkdev $BOOT_BLKDEV"


# Establish expected labels using the boot device label
BOOT_LABEL=$(blkid -s PARTLABEL -o value "$BOOT_BLKDEV" 2>/dev/null)

suffix=""; alt_suffix=""
case "$BOOT_LABEL" in
   boot*_a|boot-a|boota|boota*) suffix="${BOOT_LABEL#boot}"; alt_suffix="${suffix%a}b" ;;
   boot*_b|boot-b|bootb|bootb*) suffix="${BOOT_LABEL#boot}"; alt_suffix="${suffix%b}a" ;;
   *) die "bad boot device label '$BOOT_LABEL'";;
esac

ACTIVE_BOOT="boot${suffix}"
ACTIVE_SYS="system${suffix}"
ALT_BOOT="boot${alt_suffix}"
ALT_SYS="system${alt_suffix}"


# Slow-path (supports DM devices)
# Walk sysfs to check if a device is on the boot device.
on_bootdev() {
   dev=${1#/dev/}
   boot=${2#/dev/}

   # Try fast path
   is_boot_kname "$dev" "$boot" && return 0

   d="/sys/class/block/$dev/slaves"
   [ -d "$d" ] || return 1

   for s in "$d"/*; do
      [ -e "$s" ] || continue
      sname=${s##*/}
      on_bootdev "$sname" "$boot" && return 0
   done

   return 1
}


# Fast-path (non-DM)
# Check if a kernel name is a boot device partition.
is_boot_kname() {
   dev=${1#/dev/}
   boot=${2#/dev/}

   case "$dev" in
      "$boot"p[0-9]*) return 0 ;;
   esac
   return 1
}


# To be considered for a slot, the incoming device must be on the boot device.
if [ -n "$DM_NAME" ]; then
   on_bootdev "$DEVNAME" "$BOOT_DEV" || exit 1
else
   is_boot_kname "$DEVNAME" "$BOOT_DEV" || exit 1
fi


case "$ID_PART_ENTRY_NAME" in
   "$ACTIVE_BOOT")       slot="active/boot" ;;
   "$ACTIVE_SYS")     slot="active/system" ;;
   "$ALT_BOOT")   slot="other/boot" ;;
   "$ALT_SYS") slot="other/system" ;;
   *) exit 0 ;; # valid device but ignored
esac

if [ "$udev_fmt" -eq 1 ]; then
   echo "SLOT=${prefix}/${slot}"
else
   echo "${prefix}/${slot}"
fi

exit 0
